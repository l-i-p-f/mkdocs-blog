# 【上研极客汇·软件训战系列】字符串

## 思路与误区

**背景**

OJ考试时不会打印错误用例，一但进入误区，很难走出来

**踩坑**

- 缩小字符集的范围：区分大小写？包含除字母外的字符如符号？
- 缩小字符的出现频次：考虑字符可能不只出现一次，而是出现多次
- 忽略空字符串
- 忽略边界条件
- 全相同输入（超时考虑）
- 想着先实现再改进

**思路**

- 认真读题 - 思考极端用例
- 思考算法 - 验证用例
- 实现算法

**极端用例CheckList**

做题时可对照checklist一一构造用例

- [ ] 字符集：全ASCII？还是……
  - 使用给定用例字符外的字符

- [ ] 出现频次：是否说明字符唯一？
  - 构造用例，让字母出现频次>1

- [ ] 空字符串：是否禁止？
  - 构造空串输入

- [ ] 全相同输入：是否禁止？
  - 构造全相同输入
- [ ] 边界条件：极端情况
  - 字符串转整数时，考虑INT_MAX, INT_MIN

**其它坑**

- 内存越界：数组，string
- 整数越界
  - INT32_MAX + num
- LeetCode内存统计
  - 统计所有使用过的内存 -> 尽量避免使用拷贝



## 子串问题（滑动窗口）

### 通用解法：双指针法

适用条件：后移tail无影响或所带来的影响可以通过后移head来弥补

通用解法：时间复杂度O(N)

- 后移tail，如果新增元素会导致条件不成立时，后移head保证条件匹配

LeetCode-3：无重复字符的最长子串

```python
# 输入: "abcabcbb"
# 输出: 3 

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        """ 双指针解法 """
        n = len(s)
        if n <= 1:
            return n
        head, tail = 0, 1
        ans = 0
        while tail < n:
            if s[tail] in s[head: tail]:
                ans = max(ans, tail - head)
                # head指针后移
                head += s[head: tail].index(s[tail]) + 1
            tail += 1
        ans = max(ans, tail - head)
        return ans
```



LeetCode-76：最小覆盖子串

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。 

```python
# 输入：s = "ADOBECODEBANC", t = "ABC"
# 输出："BANC"

from collections import defaultdict

class Solution:
    def minWindow(self, s: str, t: str) -> str:
        k, n = len(t), len(s)
        if k > n:
            return ""
        
        # hashmap记录滑动窗口需要的元素
        hash_map = defaultdict(int)
        for item in t:
            hash_map[item] += 1
            
        ans = s
        head, tail = 0, 0
        need_cnt = k	# needcnt记录需要元素的总数
        flag = 0		# 标记ans是否修改

        while head <= tail:
            # 移动右指针，直到满足包含条件
            while tail < n and need_cnt:
                if hash_map[s[tail]] > 0:
                    need_cnt -= 1
                hash_map[s[tail]] -= 1
                tail += 1
            # 满足包含条件且答案更短时，更新ans
            if not need_cnt and len(ans) >= tail - head:
                flag = 1
                ans = s[head:tail]

            # 移动左指针
            if head < n:
                hash_map[s[head]] += 1
                if hash_map[s[head]] > 0:
                    need_cnt += 1
            head += 1

        return ans if flag else ""
```



### 扩展：子串匹配

常见子串匹配问题：

1. 子串**完全匹配**长串的一部分

2. 子串按**相对位置顺序**包含在长串中

3. 子串包含在长串中，**字符顺序无关**

   需要考虑以下两点：

   - 子串所有元素均出现在长串中
   - 出现元素的数量要满足包含关系



#### KMP

#### 哈希

如何判断滑动窗口内是否包含子串t所有元素？

可以使用一个哈希表 `hash_map` 来记录当前滑动窗口中**需要的各元素及数量**。初始状态滑动窗口为空，需要T中所有元素，因此，初始 `hash_map` 为：

```python
# hashmap记录滑动窗口需要的元素
hash_map = defaultdict(int)
for item in t:
	hash_map[item] += 1
    
# 假设长串为s，子串为t
s = "ADOBECODEBANC", t = "ABC"
# 则hash_map中记录了当前滑动窗口所需元素
hash_map = {'A':1, 'B':1, 'C':1}
```

当滑动窗口扩展或收缩时，去维护 `hash_map` ，当滑动窗口新增某元素时，使 `hash_map` 中该元素数量减1；当滑动窗口移除某元素时，则使 `hash_map` 中该元素数量加1。哈希表中可能出现负数的情况，表示元素是多余的，如当窗口包含`ADO`时， `hash_map` 为 `{'A':0, 'D':-1, 'O':-1, 'B':1, 'C':1}` ，表示 `D`，`O` 是多余的，此时还差一个 `B` 和 `C`。此时，当 `hash_map` 中所有元素数量均小于等于0时，表明滑动窗口包含子串中所有元素。

若每次判断滑动窗口内是否包含子串t所有元素都去遍历 `hash_map` ，时间复杂度为 `O(k)`，最坏情况下，k可能等于`len(s)`。优化手段是，维护一个额外的变量 `need_cnt` 来记录所需元素的总数量，当碰到一个所需元素在  `hash_map` 中记录大于0时，则 `need_cnt` 数量减少1，这样通过 `need_cnt` 就可以知道是否满足包含关系，无需遍历字典了。



```python
import time

start = time.time()

file_name = "subtask3"
# 读数据
with open(file_name + ".in", "r") as fin:
    data = fin.readlines()
n, q = map(int, data[0].split(" "))
files = data[1].rstrip().split(" ")
assert len(files) == n
modify = [item.rstrip().split(" ") for item in data[2:]]
tmp = 0

"""
1. 字符串比较转换为哈希数值比较
    哈希函数：f(x) = md5
2. 使用set桶存储历史版本的n个文件
    哈希函数：h(x) = f(x) * i ^ 2
"""

import hashlib
import sys

versions = set()
map_version = {}


def get_md5(s):
    h = hashlib.md5()
    h.update(s.encode("utf-8"))
    return int(h.hexdigest(), 16) % sys.maxsize


def fx_file(data):
    key = 0
    for i, item in enumerate(data):
        key += (i + 1) ** 2 + get_md5(item)
    return key


last_version = fx_file(files)
versions.add(last_version)
ver = 0
map_version[last_version] = ver

# 遍历数据
out = []
for file, content in modify:
    ver += 1
    file = int(file)
    last_version -= (file ** 2 + get_md5(files[file - 1]))
    last_version += file ** 2 + get_md5(content)
    files[file - 1] = content
    if last_version in versions:
        # print(map_version[last_version])
        out.append(map_version[last_version])
    else:
        # print(-1)
        out.append(-1)
        versions.add(last_version)
        map_version[last_version] = ver

# 读文件比较
with open(file_name + ".out", "r") as fin:
    test = fin.readlines()

for pre, ans in zip(out, test):
    if pre != int(ans):
        print("False")

print("Done")

end = time.time()
print(end - start)
```





## 回文串问题（中心对称）

- 本质上说，对象问题，以下标i或i+0.5为中心，计算左右两边字符是否镜像相等
  - 注意：bab是回文串，baab也是回文串，一定记着计算两种对称
- 往往与子串问题结合
- 常规解法
  - 暴力法：以i或i+0.5为中心，计算两种对称
  - 最长子串剪枝法
  - 最短子串剪枝法



LeetCode-125：验证回文串

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 

```python
# 输入: "A man, a plan, a canal: Panama"
# 输出: true
# 解释："amanaplanacanalpanama" 是回文串
```



LeetCode-5：最长回文子串

```python
# 输入：s = "babad"
# 输出："bab"
# 解释："aba" 同样是符合题意的答案。
```



## 前向依赖问题（状态机）

- 适合场景：处理当前需要考虑过去（前向依赖）
- 思路：将依赖表示为状态转换
- 要素：
  - 1：状态表示/处理
  - 2：转换条件
- 解题步骤：
  - 找状态
  - 找输入
  - 找状态转化的条件
  - 找状态对应的处理
- 特点
  - 代码调试模版化
  - 状态转换图画好，代码基本不会错



LeetCode-8：字符串转换整数

剑指 Offer 20. 表示数值的字符串



## 子问题求解：分形与递归

- 子问题拆分
- 生成拆分表达式
- 常用技巧
  - 使用类成员对象存储中间变量
  - 主函数调用时对类成员对象进行初始化
- 注意
  - C++尽量不要用set进行迭代，set.insert(), set.erase()开销太大



LeetCode-93：复原IP地址

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。 

给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和"192.168@1.1" 是 无效 IP 地址。 



LeetCode-87：扰乱字符串



## BFS/DFS+字符串问题

技巧：

- 中间参数->类成员
- set->bitmap，避免insert/erase
- 子函数调用避免参数拷贝传递
- 字符串生成：优先使用DFS，结合string::push_back, string::pop_back



LeetCode-17 

LeetCode-22 括号生成



## 成对匹配问题

- 适用场景：通常进行字符的匹配，如引号，括号等
- 成对字符记为cL/cR，cL...cR成对出现
- 通用算法：
  - 出现cL字符，入栈
  - 出现cR字符，出栈，判断以下条件
    - 当前栈为空，匹配失败
    - 当前栈顶不是cR字符，匹配失败
  - 字符串遍历结束，栈非空，完全匹配失败



LeetCode-20：有效的括号

LeetCode-32：最长有效括号



## 抽象语法树生成问题

- 成对匹配问题的进阶版（添加词法解析）
- 特点
  - 根节点代表操作符
  - 子节点代表操作数
  - 根节点+子节点=表达式
  - 递归/分形特性：操作数可以是表达式
- 适用题型
  - 计算器（LC227）
  - 表达式计算（LC1106）
  - 抽象语法树生成（LC385）























